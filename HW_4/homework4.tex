\documentclass{article}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage[T1]{fontenc}
\setlist{parsep=0pt, listparindent=\parindent}
\title{CMSI 386 Homework \#4}
\author{Zane Kansil \& Edward Bramanti}
\begin{document}
\maketitle
\begin{enumerate}
\item Abstract syntax tree for expression: 
\begin{center}
\begin{verbatim}
(a = 3) <= m >= ! & 4 * ~ 6 || y %= 7 ^ 6 & p
\end{verbatim}
\vspace{0.4in}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=1.5cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=1.5cm},
  level 5/.style={sibling distance=1.5cm},
  level 6/.style={sibling distance=1.5cm}
]
  \node {\textgreater=}
    child {node {\textless=}
      child {node {=}
        child {node{a}}
        child {node{3}}
      }
      child {node {m}}
    }
    child {node {||}
      child {node {!}
        child {node{\&}
          child {node{*}
            child {node{4}
            }
            child {node{\(\sim\)}
              child {node{6}
              }
            } 
          }
        }
      }
      child {node {\%=}
        child {node {y}}
        child {node {\^{}}
          child {node {7}
          }
          child {node {\&}
            child {node {6}
            }
            child {node {p}
            }
          }
        }
      }
    };
\end{tikzpicture}
\end{center}
\pagebreak
\item Non-intuitive JS semicolon ambiguities 
\begin{enumerate}
    \item The case is ambiguous because javascript will return whatever follows the return statement. The ambiguity is that JS can either return the result of an empty statement (undefined) or it can assume the users intent and return the otherwise dangling object \left\{x: 5\right\}. In this case JS returns undefined.
    
    In Python the closest translation would be:
    \begin{verbatim}
    def f():
        return
            {"x": 5}    
    \end{verbatim}
    The ambiguity is solved because Python throws an unexpected indent error on line 3.
    \item In this case the programmer has omitted the semicolons to close the initialization of b and a. This causes JS to try to call b(4 + 5).toString(16) or b("9"), this is of course an error because numbers are primitive; they cannot be called.
    In Python the closest translation would be:
    \begin{verbatim}
    b = 8
    a = b + b
    ('9')
    \end{verbatim}
    Python has no issues in this case because assignment (and other statements) are delimited by the newline character; no function call will be made. Simulating the exact scenario of the JS throws a similar 'int' object not callable error.
    \begin{verbatim}
    b = 8
    a = b + b('9')    //throws 'int' not callable
    \end{verbatim}
    \item someTitle3
    \item someTitle4
\end{enumerate}
\pagebreak
\item Give an example of a program in C that would not work correctly if local variables were allocated in static storage as opposed to the stack. For the purposes of this question, local variables do not include parameters. *Local variables init in static storage causes malfunctions*
\pagebreak
\item Statically scoped vs. Dynamically scoped
\pagebreak
\item Shallow binding vs. Deep binding
\pagebreak
\item C declarations
\begin{verbatim}
double *a[n];
double (*b)[n];
double (*c[n])();
double (*d())[n];
\end{verbatim}
\pagebreak
\item C declarations re-done in Go
\begin{verbatim}
GoSol1
GoSol2
GoSol3
GoSol4
\end{verbatim}
\pagebreak
\item Translate: (-b + sqrt(4 x a x c)) / (2 x a)
\begin{description}
    \item[(a)] postfix notation
    \item[(b)] prefix notation
    \item[(*)] urnary negation?
\end{description}
\pagebreak
\item Interleave in C++ with C-style arrays and with Vectors
\verbatimimput{interleave.cpp}
\pagebreak
\end{enumerate}
\end{document}
