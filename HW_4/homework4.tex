\documentclass{article}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage[T1]{fontenc}
\setlist{parsep=0pt, listparindent=\parindent}
\title{CMSI 386 Homework \#4}
\author{Zane Kansil \& Edward Bramanti}
\begin{document}
\maketitle
\begin{enumerate}
\item Abstract syntax tree for expression: 
\begin{center}
\begin{verbatim}
(a = 3) <= m >= ! & 4 * ~ 6 || y %= 7 ^ 6 & p
\end{verbatim}
\vspace{0.4in}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=1.5cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=1.5cm},
  level 5/.style={sibling distance=1.5cm},
  level 6/.style={sibling distance=1.5cm}
]
  \node {\textgreater=}
    child {node {\textless=}
      child {node {=}
        child {node{a}}
        child {node{3}}
      }
      child {node {m}}
    }
    child {node {||}
      child {node {!}
        child {node{\&}
          child {node{*}
            child {node{4}
            }
            child {node{\(\sim\)}
              child {node{6}
              }
            } 
          }
        }
      }
      child {node {\%=}
        child {node {y}}
        child {node {\^{}}
          child {node {7}
          }
          child {node {\&}
            child {node {6}
            }
            child {node {p}
            }
          }
        }
      }
    };
\end{tikzpicture}
\end{center}
\pagebreak
\item Non-intuitive Javascript semicolon ambiguities 
\begin{enumerate}
    \item 
    \begin{verbatim}
    function f() {
      return
         {x: 5}
    }
    \end{verbatim} \\
    The case is ambiguous because Javascript will return whatever follows the return statement. JS can either return the result of an empty statement (undefined) or it can assume the users intent and return the otherwise dangling object \{x: 5\}. In this case JS returns undefined.
    
    In Python the closest translation would be:
    \begin{verbatim}
    def f():
        return
            {"x": 5}    
    \end{verbatim}
    The ambiguity is solved because Python throws an unexpected indent error on line 3. \\
    \item 
    \begin{verbatim}
    var b = 8
    var a = b + b
    (4 + 5).toString(16)
    \end{verbatim} \\
    In this case the programmer has omitted the semicolons to delimit the initialization of b and a. This causes JS to try to call \texttt{b(4 + 5).toString(16)}, or \texttt{b("9")}. This is of course an error because numbers are primitive; they cannot be called.
    In Python the closest translation would be:
    \begin{verbatim}
    b = 8
    a = b + b
    ('0x9')
    \end{verbatim}
    Python has no issues in this case because assignment (and other statements) are delimited by the newline character; no function call will be made. Simulating the exact scenario of the JS throws a similar \texttt{int} object not callable error.
    \begin{verbatim}
    b = 8
    a = b + b('0x9')    //throws 'int' not callable
    \end{verbatim}
    \item 
    \begin{verbatim}
    var place = "mundo"
    ["Hola", "Ciao"].forEach(function (command) {
      alert(command + ", " + place)
    })
    \end{verbatim} \\
    This case is ambiguous because \texttt{"mundo"} is being indexed with the array \texttt{["Hola","Ciao"]}. The array of \texttt{["Hola","Ciao"]} can not be casted to an integer. Indexing a string with a non-integer, or an integer that is out of bounds, results in the string being evaluated to \texttt{undefined}. Therefore, the case is calling \texttt{forEach()} on \texttt{undefined}. Python solves this issue because statements end with \texttt{NEWLINE}. \\
    \item
    \begin{verbatim}
    var sayHello = function () {
      alert("Hello")
    }

    (function() {
      alert("Goodbye")
    }())
    \end{verbatim} \\
    This case is ambiguous because it seems as though \texttt{sayHello()} is a declaration, and the second function looks like it is being called. But, since there is no semicolon to break the first function definition, the parentheses around the second function act as a function call. It does not pass a value; instead, it calls a \texttt{void} function, which prints \texttt{"Goodbye"}. The script will print \texttt{"Goodbye"} first, and then \texttt{"Hello"}. Python does not run into this problem, because a function call has to be on the same line. The \texttt{NEWLINE} character will prevent anything that looks like a potential function call written on separate lines.
\end{enumerate}
\pagebreak
\item Give an example of a program in C that would not work correctly if local variables were allocated in static storage as opposed to the stack. For the purposes of this question, local variables do not include parameters. *Local variables init in static storage causes malfunctions*\\
\verbatiminput{a.c}
\pagebreak
\item Statically scoped vs. Dynamically scoped
\pagebreak
\item QUESTION REPLACED 
\pagebreak
\item C declarations
\begin{verbatim}
double *a[n];  
double (*b)[n];
double (*c[n])();
double (*d())[n];
\end{verbatim}
\begin{itemize}
    \item a is array of n pointer to double.
    \item b is pointer to array of n double.
    \item c is array of pointer to function returning double.
    \item d is function returning pointer to array of n double.
\end{itemize}
\pagebreak
\item C declarations re-done in Go
\begin{verbatim}
type doublef func() double

*[n]a double
[n]*b double
c := [n]doublef{...}
d := func() *[]double {...}
\end{verbatim}
\pagebreak
\item Translate the following expression: \texttt{(-b + sqrt(4 * a * c)) / (2 * a)}
    \item[(a)]Postfix notation: \\\texttt{b ~ 4 a * c * sqrt + 2 a * /} \\
    \item[(b)]Prefix notation: \\\texttt{/ + ~ b sqrt * * 4 a c * 2 a} \\ 
    \item[(*)] Do you need a special symbol for unary negation? Why or why not? \\
    Yes, we need a special symbol for unary negation (~, for example). We need the symbol because we are not using parentheses in the postfix and prefix notations. You can't use the same symbol unless parentheses are allowed in the answer.
\pagebreak
\item Interleave in C++ with C-style arrays and with Vectors
\verbatiminput{interleave.cpp}
\pagebreak
\end{enumerate}
\end{document}
